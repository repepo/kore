#!/usr/bin/env python
'''
kore generates submatrices

To use:
> ./bin/submatrices.py matrix
where matrix is the filename of a matrix returned by assemble.py formatted as .npz

This program reshuffles the Kore matrices, generated by assemble.py, to match the Sprouts ordering
'''

import numpy as np
import scipy.sparse as ss
import scipy.io as sio

import utils as ut
import parameters as par


def main(matrix):

    num_section = 0
    bc_per_section = np.array([], dtype=int)

    if par.hydro:
        num_section += 2
        bc_per_section = np.append(bc_per_section, [4, 2])
    if par.magnetic:
        num_section += 2
        bc_per_section = np.append(bc_per_section, [2, 2])
    if par.thermal:
        num_section += 1
        bc_per_section = np.append(bc_per_section, 2)
    if par.compositional:
        num_section += 1
        bc_per_section = np.append(bc_per_section, 2)

    kore_matrix = ut.load_csr(str(matrix))

    num_row = int(par.N)
    if not par.ricb:
        num_row = num_row/2
        bc_per_section = bc_per_section//2

    num_l = int(kore_matrix.shape[0] / (num_section * num_row))
    num_row_without_bc = num_row - bc_per_section
    num_row_without_bc = num_row_without_bc.astype(int)

    total_bc = sum(bc_per_section) * num_l
    sprouts_matrix = ss.dok_matrix(kore_matrix.shape, dtype=complex)

    for section in range(num_section):
        for l in range(num_l):
            # put equations at the bottom
            start_row_kore = int(bc_per_section[section] + (section*num_l + l)*num_row)
            start_row_sprouts = int(total_bc + num_l*sum(num_row_without_bc[:section]) + l*num_row_without_bc[section])

            sprouts_matrix[start_row_sprouts:start_row_sprouts + num_row_without_bc[section], :] \
                = kore_matrix[start_row_kore:start_row_kore + num_row_without_bc[section], :]

            # put boundary conditions at the top
            start_bc_kore = int((section*num_l + l)*num_row)
            start_bc_sprouts = int(num_l*sum(bc_per_section[:section]) + l*bc_per_section[section])

            sprouts_matrix[start_bc_sprouts:start_bc_sprouts+bc_per_section[section], :] \
                = kore_matrix[start_bc_kore:start_bc_kore+bc_per_section[section], :]

    sio.mmwrite('{}_kore.mtx'.format(str(matrix)[0]), sprouts_matrix)

    return 0


if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv[1]))
