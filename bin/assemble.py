#!/usr/bin/env python3
'''
kore assembles 

Use as:
mpiexec -n ncpus  ./bin/assemble.py
ncpus should match the value in the parameters.py file

This program takes the block matrices generated by submatrices.py
and assembles the matrix A, the matrix B, or the forcing vector.
'''

from timeit import default_timer as timer
import scipy.sparse.linalg as ssl
import scipy.sparse as ss
#import pywigxjpf as wig
from mpi4py import MPI
import scipy.io as sio
import numpy as np
import warnings
import sys
import glob

import bc_variables as bv
import parameters as par
import utils as ut
import operators as op



def main():

    warnings.simplefilter('ignore', ss.SparseEfficiencyWarning)

    # initialize Wigner-3j symbols table
    #wig.wig_table_init(2*( par.lmax + 5), 3)
    #wig.wig_temp_init(2*( par.lmax + 5))

    comm  = MPI.COMM_WORLD
    sizas = comm.Get_size()
    rank  = comm.Get_rank()

    ll_flo = ut.ell( par.m, par.lmax, par.symm)[:2]  # the ell indices for the flow u
    ll_mag = ut.ell( par.m, par.lmax, par.symm*ut.symmB0)[:2]  # if B0 is antisymm then u has the opposite symm of b

    if rank == 0:
        alltop, allbot = ll_flo
    else:
        alltop = None
        allbot = None

    nb = int((par.lmax - par.m + 1)/2)  # number of block rows per quarter
    bpp = int(nb/sizas)     # block rows per process

    loc_top = np.zeros(bpp, dtype=int)
    loc_bot = np.zeros(bpp, dtype=int)

    # split the vectors with l values and distribute to all cpu's (ranks)
    comm.Scatter(alltop, loc_top, root=0)
    comm.Scatter(allbot, loc_bot, root=0)

    if ut.symmB0 == 1:  # symmetric B0
        loc_mag_f = loc_top
        loc_mag_g = loc_bot
    elif ut.symmB0 == -1:  # antisymmetric B0
        loc_mag_f = loc_bot
        loc_mag_g = loc_top


    if   par.forcing == 1: # -------------------------------------------------------------------------- Yufeng's forcing
        '''
        Builds the right hand side vector for the forced problem
        Lin 2018 body forcing
        l=3, m=2 Toroidal scalar only
        equatorially symmetric
        '''
        if rank == 0: # only one cpu is enough

            if par.symm==1 and par.m==2:

                pos = ut.n + ut.N1*np.where(allbot==3)[0][0] # finds where the l=3 toroidals begin
                row = np.arange(pos,pos+ut.N1) # start at pos+2 because of the 2 rows with bc's
                col = np.zeros(ut.N1)

                bdat = op.Ig*ut.chebco(-2, ut.N1, 3e-16, par.ricb, ut.rcmb) * ( -4*np.sqrt(5)*(par.ricb**5)/(1-par.ricb**5) ) * par.forcing_amplitude_cmb
                B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )

                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print('Lin & Ogilvie 2018 forcing needs symm = 1 and m = 2')


    elif par.forcing == 2: # -------------------------------------------------------- Jeremy's eccentricity tide forcing
        '''
        Builds the right hand side vector for the forced problem.
        This is Jeremy's tidal forcing as a boundary flow,
        l=2 Poloidal scalar only, equatorially symmetric.
        '''
        if rank == 0:

            if par.symm == 1 and (par.m==0 or par.m==2) and (par.bci+par.bco==2):

                pos = ut.N1*np.where(alltop==2)[0][0]
                row = np.arange(pos,pos+4)  # forcing goes as a boundary condition
                col = np.zeros(4)

                fcmb = 1j*par.forcing_amplitude * ut.eccen_tide(par.m*sign(par.forcing_frequency),par.ricb,'cmb')
                ficb = 1j*par.forcing_amplitude * ut.eccen_tide(par.m*sign(par.forcing_frequency),par.ricb,'icb')

                bdat = np.array([ficb[0], ficb[1], fcmb[0], fcmb[1]])
                B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )

                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print('Jeremy\'s forcing needs symm = 1 and m = 0 or 2 and bci=bco=1')


    elif par.forcing == 3: # ---------------------------------------------------------------------------- Marc's forcing
        '''
        Builds the right hand side vector for forced problems
        This is the tidal forcing from Rovira-Navarro et al 2018
        '''
        if rank == 0:

            if par.m < 3:

                l = 3  # goes with the toroidals (1curl eqs)
                pos3 = ut.n + ut.N1*np.where(allbot==l)[0][0]
                row3 = np.arange(pos3+2,pos3+ut.N1)
                col3 = np.zeros(ut.N1-2)
                bdat3 = ut.marc_tide(ut.wf,3,par.m,'bot',ut.N1, par.ricb, ut.rcmb)*par.forcing_amplitude
                tmp = [bdat3, row3, col3]
                blist = tmp

                l = 2 # goes with the poloidals (2curl eqs)
                pos2 = ut.N1*np.where(alltop==l)[0][0]
                row2 = np.arange(pos2+4,pos2+ut.N1)
                col2 = np.zeros(ut.N1-4)
                bdat2 = ut.marc_tide(ut.wf,2,par.m,'top',ut.N1, par.ricb, ut.rcmb)*par.forcing_amplitude
                tmp = [bdat2, row2, col2]
                for q in [0,1,2]:
                    blist[q]= np.concatenate((blist[q], tmp[q]))

                if par.m < 2:
                    l = 1 # goes with the toroidals (1curl eqs)
                    pos1 = ut.n + ut.N1*np.where(allbot==l)[0][0]
                    row1 = np.arange(pos1+2,pos1+ut.N1)
                    col1 = np.zeros(ut.N1-2)
                    bdat1 = ut.marc_tide(ut.wf,1,par.m,'bot',ut.N1, par.ricb, ut.rcmb)*par.forcing_amplitude
                    tmp = [bdat1, row1, col1]
                    for q in [0,1,2]:
                        blist[q]= np.concatenate((blist[q], tmp[q]))

                B = ss.csr_matrix( ( blist[0], (blist[1],blist[2]) ), shape=(ut.sizmat,1) )

                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print('Rovira-Navarro forcing requires m < 3')


    elif par.forcing == 4: # -------------------------------------------------- forcing test 1 (Jeremy's volume forcing)
        # see mathematica notebook forcing_test1_jeremy.nb
        if rank == 0:
            print('Jeremy\'s body forcing')
            if par.symm == 1 and par.m == 2:

                X = ut.ftest1(par.ricb)
                XA = X[0]
                XB = X[1]
                XC = X[2]

                l = 3 # goes with the toroidals (1curl eqs), Gegenbauer order 2 basis

                F2 = Ib*ut.chebco(-2, ut.N1, 3e-16, par.ricb, ut.rcmb)

                #bdat = Ib*chebco(-2,ut.N1,3e-16) * ( -4*np.sqrt(5)*(par.ricb**5)/(1-par.ricb**5) ) * par.forcing_amplitude
                #print(F2[:4])

                pos3 = ut.n + ut.N1*np.where(allbot==l)[0][0]
                row3 = np.arange(pos3, pos3 + ut.N1)
                col3 = np.zeros(ut.N1)
                bdat3 = par.forcing_amplitude * (-4*np.sqrt(5))*XB*F2 *XC
                tmp = [bdat3, row3, col3]
                blist = tmp

                B = ss.csr_matrix( ( blist[0], (blist[1],blist[2]) ), shape=(ut.sizmat,1) )
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:
                print('Forcing test 1 requires m = 2')


    elif par.forcing == 5: # ---------------------------------------------------------------------------- forcing test 2

        if rank == 0:

            if par.m == 0:

                F2 = r2Ib*ut.chebco(-2, ut.N1, 3e-16, par.ricb, ut.rcmb)

                l = 1 # goes with the toroidals (1curl eqs), Gegenbauer order 2 basis
                pos1 = ut.n+ut.N1*np.where(allbot==l)[0][0]
                row1 = np.arange(pos1,pos1+ut.N1)
                col1 = np.zeros(ut.N1)
                bdat1 = par.forcing_amplitude * (-4/5)*F2
                print(bdat1[:6])
                tmp = [bdat1, row1, col1]
                blist = tmp

                l = 3 # goes with the toroidals (1curl eqs), Gegenbauer order 2 basis

                pos3 = ut.n+ut.N1*np.where(allbot==l)[0][0]
                row3 = np.arange(pos3,pos3+ut.N1)
                col3 = np.zeros(ut.N1)
                bdat3 = par.forcing_amplitude * (-36/5)*F2
                print(bdat3[:6])
                tmp = [bdat3, row3, col3]
                for q in [0,1,2]:
                    blist[q]= np.concatenate((blist[q], tmp[q]))

                B = ss.csr_matrix( ( blist[0], (blist[1],blist[2]) ), shape=(ut.sizmat,1) )
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print('Forcing test 2 requires m = 0')


    elif par.forcing == 6: # -------------------------------------------------- Buffett 2010 ICB radial velocity forcing

        if rank == 0:
            print('Buffett 2010 ICB radial velocity forcing')

            if par.m == 1 and par.symm == -1:

                l = 2 # goes with the poloidals (2curl eqs) at the rows for the ICB boundary conditions

                pos = ut.N1*np.where(alltop==l)[0][0]  # pos should be zero
                row = np.arange(pos,pos+2)
                col = np.zeros(2)

                hft = 0.0025 # Inner core hydrostating flattening
                C   = (1j)*(2/3)*np.sqrt(6)*hft*par.ricb

                P   = ( par.ricb/(l*(l+1)) ) * C * par.forcing_amplitude
                dP  = -P/par.ricb
                d2P = (2-l*(l+1))*P/(par.ricb**2)

                if par.bci == 0: # stress-free
                    #bdat = -1j*ut.wf*np.array([P, d2P])
                    bdat = np.array([P, d2P])

                elif par.bci == 1: # no-slip
                    #bdat = -1j*ut.wf*np.array([P,  dP])
                    bdat = np.array([P,  dP])

                B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print('Buffet2010 forcing requires m = 1, symm = -1')


    elif par.forcing == 7: # ------------------------------------------------------------ longitudinal libration forcing

        # libration in longitude as a boundary flow forcing
        if rank == 0:

            if par.m == 0 and par.symm == 1 and par.bci == 1 and par.bco == 1:

                print('--------------------------------------------')
                print('Longitudinal libration - axial forcing (m = 0)')
                print('--------------------------------------------')

                l = 1   # l=1 Toroidal boundary forcing

                pos = ut.n + ut.N1*np.where(allbot==l)[0][0]
                row = np.arange(pos,pos+2)
                col = np.zeros(2)

                # forcing amplitude is (1/2) of libration amplitude in radians
                C_icb = 1j* par.forcing_frequency * par.forcing_amplitude_icb * par.ricb / 2
                C_cmb = 1j* par.forcing_frequency * par.forcing_amplitude_cmb / 2 # rcmb is 1

                bdat = np.array([C_cmb, C_icb])

                B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            elif par.m == 2 and par.symm == 1 and par.bci == 1 and par.bco == 1:

                print('--------------------------------------------')
                print('Longitudinal libration - radial forcing (m = {:n})'.format(np.sign(par.forcing_frequency)*par.m))
                print('--------------------------------------------')

                l = 2  # up to first order the moving boundary corresponds to the degree 2 components.
                L = l * (l + 1)

                pos = ut.N1 * np.where(alltop == l)[0][0]
                row = np.arange(pos, pos + 2)
                col = np.zeros(2)

                # amplitude for the l=2 components
                C_cmb = -par.forcing_frequency / L * par.forcing_amplitude_cmb
                C_icb = -par.forcing_frequency / L * par.forcing_amplitude_icb * (par.ricb ** 2)

                bdat = np.array([C_cmb, C_icb])

                B = ss.csr_matrix((bdat, (row, col)), shape=(ut.sizmat, 1))
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print(' ** Longitudinal libration requires m = 0, symm = 1 and no-slip boundaries **')


    elif par.forcing == 8: # ------------------------------------------------------------ longitudinal libration forcing

        # libration in longitude as a Poincaré (volume) force
        if rank == 0:

            print('--------------------------------------------')
            print(' Longitudinal libration - volume forcing    ')
            print('--------------------------------------------')

            if par.m == 0 and par.symm == 1 and par.bci == 1 and par.bco == 1:

                l = 1   # l=1,m=0

                pos = ut.n + ut.N1*np.where(allbot==l)[0][0]
                row = np.arange(pos,pos+ut.N1)
                col = np.zeros(ut.N1)

                # amplitude is max libration angle
                C = 2*(par.forcing_frequency**2) * par.forcing_amplitude_cmb
                bdat = C * op.Iv * ut.chebco(3,ut.N1,1e-9,par.ricb,1)

                B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print(' ** Longitudinal libration requires m = 0, symm = 1 and no-slip boundaries **')


    elif par.forcing == 9: # --------------------------------------------------------------- m=2 radial velocity forcing

        # m=2 radial velocity forcing at the icb or cmb, l=2 Poloidal scalar only, equatorially symmetric.
        if rank == 0:

            print('--------------------------------------------')
            print(' m=2 radial velocity forcing                ')
            print('--------------------------------------------')

            if (par.symm == 1 and par.m==2) and (par.bci==1):

                l = 2   #
                L = l*(l+1)

                pos = ut.N1*np.where(alltop==l)[0][0]
                row = np.arange(pos,pos+2)
                col = np.zeros(2)

                #C_icb = L*par.m*par.forcing_frequency*par.forcing_amplitude_icb/par.ricb  # to be checked
                #C_cmb = L*par.m*par.forcing_frequency*par.forcing_amplitude_cmb

                # forcing amplitude is the radial velocity amplitude
                C_icb = par.forcing_amplitude_icb * par.ricb / L
                C_cmb = par.forcing_amplitude_cmb * ut.rcmb / L

                bdat = np.array([C_cmb, C_icb])

                B = ss.csr_matrix( ( bdat, (row,col) ), shape=(ut.sizmat,1) )
                np.savez('B_forced.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)

            else:

                print('This boundary flow forcing needs symm = 1 and m = 2 and bci = 1')



    elif par.forcing == 0: # ----------------------------------------------------------------------------------------------------- B matrix, no forcing (eigenvalue problem)
        '''
        Builds the right hand side B matrix to solve
        the generalized eigenvalue problem A.x = lambda.B.x
        '''
        if rank == 0:
            tic = timer()

        if par.hydro == 1:

            # ----------------------------------------------------------------------- B matrix, 2curl (hydro), section u
            for k,l in enumerate(loc_top):

                row = ( rank*bpp + k )* ut.N1
                col = row

                mtx = -op.u(l,'u','upol',0)
            
                if l == loc_top[0]:  # create loc_list if first iteration
                    mtx.eliminate_zeros()
                    mtx = mtx.tocoo()
                    loc_list = [mtx.data, mtx.row + row , mtx.col + col]
                else:  # append to loc_list if it already exists
                    loc_list = ut.packit(loc_list, mtx, row, col)               
                        

            # ----------------------------------------------------------------------- B matrix, 1curl (hydro), section v
            for k,l in enumerate(loc_bot):

                row = nb*ut.N1 + ( rank*bpp + k )* ut.N1
                col = row

                mtx = -op.u(l,'v','utor',0)
                
                loc_list = ut.packit(loc_list, mtx, row, col)
                


        if par.magnetic == 1: # adds -(d/dt)*b in the induction equation to matrix B

            # ---------------------------------------------------------------------- B matrix (induction eq.), section f
            for k,l in enumerate(loc_mag_f):  # same as loc_bot if B0 is antisymm

                row = par.hydro*(2*nb*ut.N1) + ( rank*bpp + k )* ut.N1
                col = row

                if par.ricb == 0 or (par.innercore in ['insulator', 'TWA', 'conducting']) :
                    mtx = -op.b(l,'f','bpol',0)
                else :
                    print('These magnetic parameters are not coded yet')

                loc_list = ut.packit(loc_list, mtx, row, col)


            # --------------------------------------------------------------- B matrix, 1curl (induction eq.), section g
            for k,l in enumerate(loc_mag_g):  # same as loc_top if B0 is antisymm

                row = par.hydro*(2*nb*ut.N1) + nb*ut.N1 + ( rank*bpp + k )* ut.N1
                col = row

                if par.ricb == 0 or (par.innercore in ['insulator', 'TWA', 'conducting']) :
                    mtx = -op.b(l,'g','btor',0)
                else :
                    print('These magnetic parameters are not coded yet')

                loc_list = ut.packit(loc_list, mtx, row, col)


        if par.thermal == 1: # adds (d/dt)*theta in the heat equation to matrix B

            # ------------------------------------------------------------------- B, theta_pol, nocurl (heat), section h
            for k,l in enumerate(loc_top):  # loc_top here because theta
                                            # follows the same symmetry as u
                row = 2*(par.hydro + par.magnetic)*nb*ut.N1 + ( rank*bpp + k )* ut.N1
                col = row

                mtx = op.theta(l,'h','', 0)

                loc_list = ut.packit(loc_list, mtx, row, col)


        if par.compositional == 1: # adds (d/dt)*xi in the compositional equation to matrix B

            # ------------------------------------------------------------------- B, theta_pol, nocurl (heat), section i
            for k,l in enumerate(loc_top):  # loc_top here because xi
                                            # follows the same symmetry as u
                row = (2*par.hydro + 2*par.magnetic + par.thermal)*nb*ut.N1 + ( rank*bpp + k )* ut.N1
                col = row

                mtx = op.composition(l,'i','', 0)

                loc_list = ut.packit(loc_list, mtx, row, col)


        # ---------------------------------------------------------------------- B matrix assembly
        # We use comm.Allgather here to figure out the right size
        # for the local variables bdat, brow and bcol.
        # They all need to be the same size for comm.Gather to work with them.

        s = np.shape(loc_list[0])[0]
        alls = comm.allgather(s)
        length = max(alls)

        bdat = np.zeros(length)
        brow = -np.ones(length)
        bcol = -np.ones(length)

        bdat[:s] = loc_list[0]
        brow[:s] = loc_list[1]
        bcol[:s] = loc_list[2]

        # fdat, frow and fcol are variables that will store the full B matrix
        # a Gather command will send all local data from each rank (bdat, brow, bcol)
        # to the rank 0 process.

        fdat = None
        frow = None
        fcol = None

        # We need to initialize explicitely the variables in rank 0:
        if rank == 0:
            fdat = np.zeros(length*sizas)
            frow = np.zeros(length*sizas)
            fcol = np.zeros(length*sizas)

        # and finally gather all local data to (fdat,frow,fcol)
        comm.Gather(bdat,fdat,root=0)
        comm.Gather(brow,frow,root=0)
        comm.Gather(bcol,fcol,root=0)

        if rank == 0:
            #print(ut.sizmat)
            ix = np.where(frow >= 0)
            B = ss.csr_matrix( ( fdat[ix], (frow[ix], fcol[ix]) ) , shape=(ut.sizmat,ut.sizmat) )
            Bnorm = ssl.norm(B)
            #Bnorm=1
            B = B/Bnorm

            toc = timer()
            print('--------------------------------------------')
            print(' Matrix B assembled in', '{: 4.3f}'.format(toc-tic), 'seconds')
            tic = timer()

            np.savez('B.npz', data=B.data, indices=B.indices, indptr=B.indptr, shape=B.shape)
            toc = timer()
            print(' Matrix B written to disk in', '{: 4.3f}'.format(toc-tic), 'seconds')
            print('--------------------------------------------')

        comm.Barrier()





    if rank == 0:
        tic = timer()


    if par.hydro == 1:
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------------------- A matrix, 2curl hydro (section u)
        # ------------------------------------------------------------------------------------------------------------------------------------------------
        for k,l in enumerate(loc_top): # 2curl hydro eqs
            
            col0 = ( rank*bpp + k )* ut.N1
            row  = col0


            # Poloidal velocity terms (upol) ---------------------------------------------------------------------------
            # ------------------------------------------------------------------------------- A, 2curl (section u), upol
            # ----------------------------------------------------------------------------------------------------------
            basecol = 0
            
            # Physics ----------------------------------------------
            iwu  = op.u(l,'u','upol',0)*1j*ut.wf
            cori = op.coriolis(l,'u','upol',0)[0]
            visc = op.viscous_diffusion(l,'u','upol',0)
            mtx = iwu + cori - visc
            # ------------------------------------------------------
            col = basecol + col0
            if l == loc_top[0]:  # create loc_list if first iteration
                mtx.eliminate_zeros()
                mtx = mtx.tocoo()
                loc_list = [mtx.data, mtx.row + row , mtx.col + col]
            else:  # append to loc_list if it already exists
                loc_list = ut.packit(loc_list, mtx, row, col)
    
    
            # Toroidal velocity terms (utor) ---------------------------------------------------------------------------
            # ------------------------------------------------------------------------------- A, 2curl (section u), utor
            # ----------------------------------------------------------------------------------------------------------
            basecol = nb*ut.N1
            
            for i in [-1,1]:
                
                if l+i in ll_flo[1] :
                
                    # Physics ---------------------------------------
                    mtx = op.coriolis(l,'u','utor',i)
                    # -----------------------------------------------
                    col = basecol + col0 + mtx[1] * ut.N1
                    loc_list = ut.packit( loc_list, mtx[0], row, col)


            if par.magnetic == 1: # include Lorentz force
                
                # Lorentz force, poloidal magnetic field terms (bpol) --------------------------------------------------
                # --------------------------------------------------------------------------- A, 2curl (section u), bpol
                # ------------------------------------------------------------------------------------------------------
                basecol = 2*nb*ut.N1  # bpol

                for i in [ -2, -1, 0, 1, 2 ]:
                    
                    if l+i in ll_mag[0]:  # for bpol, so we use ll_mag[0]
                        
                        # Physics ---------------------------------------
                        mtx = op.lorentz(l,'u','bpol', i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)   

                 
                # Lorentz force, toroidal magnetic field terms (btor) --------------------------------------------------
                # --------------------------------------------------------------------------- A, 2curl (section u), btor
                # ------------------------------------------------------------------------------------------------------
                basecol = 3*nb*ut.N1  # btor

                for i in [ -1, 0, 1 ]:
                    
                    if l+i in ll_mag[1]:
                        
                        # Physics ---------------------------------------
                        mtx = op.lorentz(l,'u','btor', i)               
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)


            if par.thermal == 1 : # include the buoyancy force
                
                # Buoyancy force, theta (temperature) terms ------------------------------------------------------------ 
                # --------------------------------------------------------------------------- A, 2curl (section u), temp
                # ------------------------------------------------------------------------------------------------------
                basecol = ( 2 + 2*par.magnetic )*nb*ut.N1          

                # Physics ------------------------------------
                mtx = -op.buoyancy(l,'u','',0)
                # --------------------------------------------
                col = basecol + col0
                loc_list = ut.packit( loc_list, mtx, row, col)


            if par.compositional == 1 : # include the compositional buoyancy

                # Compositional buoyancy force, xi (composition) terms ------------------------------------------------- 
                # --------------------------------------------------------------------------- A, 2curl (section u), comp
                # ------------------------------------------------------------------------------------------------------
                basecol = ( 2 + 2*par.magnetic + par.thermal )*nb*ut.N1          

                # Physics ------------------------------------
                mtx = -op.comp_buoyancy(l,'u','',0)
                # --------------------------------------------
                col = basecol + col0
                loc_list = ut.packit( loc_list, mtx, row, col)


            # ----------------------------------------------------------------------------------------------------------
            # ---------------------------- include poloidal velocity boundary conditions and update loc_list (section u)
            # ----------------------------------------------------------------------------------------------------------
            bc_u_list = bc_u_spherical( l, 'section_u' )
            for q in [0,1,2]:   
                loc_list[q]= np.concatenate( ( loc_list[q], bc_u_list[q] ) )
            # ----------------------------------------------------------------------------------------------------------



        # ------------------------------------------------------------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------------------- A matrix, 1curl hydro (section v)
        # ------------------------------------------------------------------------------------------------------------------------------------------------
        for k,l in enumerate(loc_bot): # 1curl Navier-Stokes equations
        
            col0 = (rank*bpp + k )* ut.N1
            row  = col0 + nb*ut.N1


            # Poloidal velocity terms (upol) ---------------------------------------------------------------------------
            # ------------------------------------------------------------------------------- A, 1curl (section v), upol
            # ----------------------------------------------------------------------------------------------------------
            basecol = 0
            
            for i in [ -1, 1 ]:
                
                if l+i in ll_flo[0]:  # for upol, so we use ll_flo[0]
                    
                    # Physics ---------------------------------------
                    mtx = op.coriolis(l,'v','upol', i)
                    # -----------------------------------------------
                    col = basecol + col0 + mtx[1]*ut.N1
                    loc_list = ut.packit( loc_list, mtx[0], row, col)

        
            # Toroidal velocity terms ----------------------------------------------------------------------------------
            # ------------------------------------------------------------------------------- A, 1curl (section v), utor
            # ----------------------------------------------------------------------------------------------------------
            basecol = nb*ut.N1
    
            # Physics ------------------------------------
            iwu  = op.u(l,'v','utor',0)*1j*ut.wf
            cori = op.coriolis(l,'v','utor',0)[0]
            visc = op.viscous_diffusion(l,'v','utor',0)
            mtx = iwu + cori - visc
            # --------------------------------------------
            col = basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)


            if par.magnetic == 1: # includes the Lorentz force
                                
                # Lorentz force, poloidal magnetic field terms (bpol) --------------------------------------------------
                # --------------------------------------------------------------------------- A, 1curl (section v), bpol
                # ------------------------------------------------------------------------------------------------------
                basecol = 2*nb*ut.N1  #bpol
                
                for i in [ -1, 0, 1 ]:
                    
                    if l+i in ll_mag[0]:
                        
                        # Physics ---------------------------------------
                        mtx = op.lorentz(l,'v','bpol', i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)


                # Lorentz force, toroidal magnetic field terms (btor) --------------------------------------------------
                # --------------------------------------------------------------------------- A, 1curl (section v), btor
                # ------------------------------------------------------------------------------------------------------
                basecol = 3*nb*ut.N1  # btor

                for i in [ -2, -1, 0, 1, 2 ]:
                    
                    if l+i in ll_mag[1]:  # for b_tor, so we use ll_mag[1]
                    
                        # Physics ---------------------------------------
                        mtx = op.lorentz( l, 'v', 'btor', i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)


            # ----------------------------------------------------------------------------------------------------------
            # ----------------------------------------------------------------------------- No temp or comp terms needed
            # ----------------------------------------------------------------------------------------------------------


            # ----------------------------------------------------------------------------------------------------------
            # ---------------------------- include toroidal velocity boundary conditions and update loc_list (section v)
            # ----------------------------------------------------------------------------------------------------------
            bc_u_list = bc_u_spherical( l, 'section_v' )
            if (bc_u_list is None):  # no bc needed in section v if inviscid
                pass
            else:
                for q in [0,1,2]:   
                    loc_list[q]= np.concatenate( ( loc_list[q], bc_u_list[q] ) )
            # ----------------------------------------------------------------------------------------------------------



    if par.magnetic == 1: # includes the induction equation
        
        # Submatrices here for nocurl and 1curl eqs have only 3 and 2 rows empty at the top, respectively
        # instead of 4 to make room for the magnetic boundary conditions
        # -----------------------------------------------------------------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------------------- A matrix, nocurl induction (section f)
        # -----------------------------------------------------------------------------------------------------------------------------------------------------
        for k,l in enumerate(loc_mag_f): # same as loc_bot if B0 is antisymm, or as loc_top if B0 is symm
        
            col0 = (rank*bpp + k )* ut.N1
            row  = par.hydro*(2*nb*ut.N1) + col0


            if par.hydro == 1:
                
                # Poloidal velocity terms: curl ( B0 x u ) -------------------------------------------------------------
                # ---------------------------------------------------------------- A, nocurl induction (section f), upol
                # ------------------------------------------------------------------------------------------------------
                basecol = 0
                
                for i in [ -2, -1, 0, 1, 2 ]:
                    
                    if l+i in ll_flo[0]:
                        
                        # Physics ---------------------------------------
                        mtx = op.induction(l, 'f', 'upol', i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)


                # Toroidal velocity terms ------------------------------------------------------------------------------
                # ---------------------------------------------------------------- A, nocurl induction (section f), utor
                # ------------------------------------------------------------------------------------------------------
                basecol = nb*ut.N1  # utor

                for i in [ -1, 0, 1 ]:
                    
                    if l+i in ll_flo[1]:
                        
                        # Physics ---------------------------------------
                        mtx = op.induction(l,'f','utor', i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)
                            
            
            # Poloidal magnetic field terms (diffusion + iwb term) -----------------------------------------------------
            # -------------------------------------------------------------------- A, nocurl induction (section f), bpol
            # ----------------------------------------------------------------------------------------------------------
            basecol = par.hydro*(2*nb*ut.N1)

            # Physics ------------------------------------
            difus = op.magnetic_diffusion(l,'f','bpol',0)
            iwb   = 1j*ut.wf * op.b(l,'f','bpol',0)
            mtx   = iwb - difus
            # --------------------------------------------
            col  =  basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)
            

            # Toroidal magnetic terms (diffusion term + iwb term) ------------------------------------------------------
            # -------------------------------------------------------------------- A, nocurl induction (section f), btor
            # ----------------------------------------------------------------------------------------------------------
            # Empty
            
            
            # ----------------------------------------------------------------------------------------------------------
            # ----------------------------------------------------------------------------- No temp or comp terms needed
            # ----------------------------------------------------------------------------------------------------------
            
            
            # ----------------------------------------------------------------------------------------------------------
            # ------------------------------------- include magnetic boundary conditions and update loc_list (section f)
            # ----------------------------------------------------------------------------------------------------------
            if par.ricb > 0 :
                if par.innercore == 'TWA' :
                    bc_b_list_inner = bc_b_thinlayer(l, 'nocurl', 1/par.mu, par.c_icb, par.c1_icb, 'icb')
                else:
                    bc_b_list_inner = bc_b_icb( l, 'nocurl', par.innercore, rank, bpp, k)
            
            if par.mantle == 'TWA':
                bc_b_list_outer = bc_b_thinlayer(l, 'nocurl', 1/par.mu, par.c_cmb, par.c1_cmb, 'cmb')
            else:
                bc_b_list_outer = bc_b_cmb( l, 'section_f', par.innercore )
            
            for q in [0,1,2]:
                if par.ricb > 0:
                    loc_list[q]= np.concatenate( ( loc_list[q], bc_b_list_inner[q], bc_b_list_outer[q] ) )
                else:
                    loc_list[q]= np.concatenate( ( loc_list[q], bc_b_list_outer[q] ) )
            # ----------------------------------------------------------------------------------------------------------


        # ----------------------------------------------------------------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------------------- A matrix, 1curl induction (section g)
        # ----------------------------------------------------------------------------------------------------------------------------------------------------
        for k,l in enumerate(loc_mag_g): # same as loc_top if B0 is antisymm
            
            col0 = ( rank*bpp + k )* ut.N1
            row  = nb*ut.N1*(1+2*par.hydro) + col0  

            
            if par.hydro == 1:
            
                # Poloidal velocity terms ------------------------------------------------------------------------------
                # ----------------------------------------------------------------- A, 1curl induction (section g), upol
                # ------------------------------------------------------------------------------------------------------
                basecol = 0
                
                for i in [ -1, 0, 1]:
                    
                    if l+i in ll_flo[0]:
                        
                        # Physics ---------------------------------------
                        mtx = op.induction(l,'g','upol',i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1
                        loc_list = ut.packit( loc_list, mtx[0], row, col)

                
                # Toroidal velocity terms ------------------------------------------------------------------------------
                # ----------------------------------------------------------------- A, 1curl induction (section g), utor
                # ------------------------------------------------------------------------------------------------------
                basecol = nb*ut.N1
                
                for i in [ -2, -1, 0, 1, 2 ]:
                    
                    if l+i in ll_flo[1]:
                    
                        # Physics ---------------------------------------
                        mtx = op.induction(l,'g','utor',i)
                        # -----------------------------------------------
                        col = basecol + col0 + mtx[1] * ut.N1                    
                        loc_list = ut.packit( loc_list, mtx[0], row, col)
                    
                    
            # Poloidal magnetic terms (diffusion + iwb term) -----------------------------------------------------------
            # --------------------------------------------------------------------- A, 1curl induction (section g), bpol
            # ----------------------------------------------------------------------------------------------------------
            # Empty

    
            
            # Toroidal magnetic terms (diffusion + iwb term) -----------------------------------------------------------
            # --------------------------------------------------------------------- A, 1curl induction (section g), btor
            # ----------------------------------------------------------------------------------------------------------
            basecol = nb*ut.N1*(1+2*par.hydro)
            
            # Physics ------------------------------------
            difus = op.magnetic_diffusion(l,'g','btor',0)
            iwb   = 1j*ut.wf * op.b(l,'g','btor',0)
            mtx = iwb - difus
            # --------------------------------------------
            col =  basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)


            # ----------------------------------------------------------------------------------------------------------
            # ----------------------------------------------------------------------------- No temp or comp terms needed
            # ----------------------------------------------------------------------------------------------------------
            
            
            # ----------------------------------------------------------------------------------------------------------
            # ------------------------------------- include magnetic boundary conditions and update loc_list (section g)
            # ----------------------------------------------------------------------------------------------------------
            if par.ricb > 0 :
                if par.innercore == 'TWA' :
                    bc_b_list_inner = bc_b_thinlayer(l, '1curl', 1/par.mu, par.c_icb, par.c1_icb, 'icb')
                else:
                    bc_b_list_inner = bc_b_icb( l, '1curl', par.innercore, rank, bpp, k)
            
            if par.mantle == 'TWA':
                bc_b_list_outer = bc_b_thinlayer(l, '1curl', 1/par.mu, par.c_cmb, par.c1_cmb, 'cmb')
            else:
                bc_b_list_outer = bc_b_cmb( l, 'section_g', par.innercore )
                
            for q in [0,1,2]:
                if par.ricb > 0:
                    loc_list[q]= np.concatenate( ( loc_list[q], bc_b_list_inner[q], bc_b_list_outer[q] ) )
                else:
                    loc_list[q]= np.concatenate( ( loc_list[q], bc_b_list_outer[q] ) )
            # ----------------------------------------------------------------------------------------------------------



    if par.thermal == 1: # includes the heat equation
        
        # Submatrices here for nocurl have only 2 rows empty at the top
        # instead of 4 to make room for the thermal boundary conditions

        # --------------------------------------------------------------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------------------- A matrix, heat equation (section h)
        # --------------------------------------------------------------------------------------------------------------------------------------------------
        for k,l in enumerate(loc_top): # here use the l's from loc_top 
        
            col0 = (rank*bpp + k )* ut.N1
            row = (2+2*par.magnetic)*nb*ut.N1 + col0
            
            # Poloidal velocity terms: -u_r * (d/dr)T ------------------------------------------------------------------
            # ----------------------------------------------------------------------- A, heat equation (section h), upol
            # ----------------------------------------------------------------------------------------------------------
            basecol = 0             

            # Physics ------------------------------------
            mtx = op.thermal_advection(l,'h','upol',0)
            # --------------------------------------------
            col = basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)

            
            # temperature (theta) terms: (Ek/Pr)*nabla**2(theta) -------------------------------------------------------
            # ----------------------------------------------------------------------- A, heat equation (section h), temp
            # ----------------------------------------------------------------------------------------------------------
            basecol = (2+2*par.magnetic)*nb*ut.N1       
            
            # Physics ----------------------------
            mtx = op.thermal_diffusion(l,'h','',0)
            # ------------------------------------
            col = basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)    
            
            
            # ----------------------------------------------------------------------------------------------------------
            # -------------------------------------------------- include thermal boundary conditions and update loc_list
            # ----------------------------------------------------------------------------------------------------------
            bc_theta_list = bc_theta_spherical( l )
            for q in [0,1,2]:   
                loc_list[q]= np.concatenate( ( loc_list[q], bc_theta_list[q] ) )
            # ----------------------------------------------------------------------------------------------------------



    if par.compositional == 1: # includes the composition equation
        
        # Submatrices here for nocurl have only 2 rows empty at the top
        # instead of 4 to make room for the thermal boundary conditions

        # ---------------------------------------------------------------------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------------------- A matrix, composition equation (section i)
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------
        for k,l in enumerate(loc_top): # here use the l's from loc_top 
        
            col0 = (rank*bpp + k )* ut.N1
            row = ( 2 + 2*par.magnetic + par.thermal )*nb*ut.N1 + col0
            
            # Poloidal velocity terms: -u_r * (d/dr)xi -----------------------------------------------------------------
            # ---------------------------------------------------------------- A, composition equation (section i), upol
            # ----------------------------------------------------------------------------------------------------------
            basecol = 0             

            # Physics --------------------------------------
            mtx = op.compositional_advection(l,'i','upol',0)
            # ----------------------------------------------
            col = basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)

            
            # Compositional (xi) terms: (Ek/Sc)*nabla**2(xi) -----------------------------------------------------------
            # ---------------------------------------------------------------- A, composition equation (section i), comp
            # ----------------------------------------------------------------------------------------------------------
            basecol = ( 2 + 2*par.magnetic + par.thermal )*nb*ut.N1 
            
            # Physics ----------------------------------
            mtx = op.compositional_diffusion(l,'i','',0)
            # ------------------------------------------
            col = basecol + col0
            loc_list = ut.packit( loc_list, mtx, row, col)    
            
            
            # ----------------------------------------------------------------------------------------------------------
            # -------------------------------------------- include compositional boundary conditions and update loc_list
            # ----------------------------------------------------------------------------------------------------------
            bc_xi_list = bc_xi_spherical( l )
            for q in [0,1,2]:   
                loc_list[q]= np.concatenate( ( loc_list[q], bc_xi_list[q] ) )
            # ----------------------------------------------------------------------------------------------------------



    # ------------------------------------------------------------------------------------------------------------------ A matrix assembly
    # We use comm.allgather here to figure out the right size
    # for the local variables bdat, brow and bcol.
    # They all need to be the same size for comm.Gather to work with them.

    s = np.shape(loc_list[0])[0]
    alls = comm.allgather(s)
    length = max(alls)

    bdat = np.zeros(length,dtype=complex)
    brow = -np.ones(length,dtype=np.int64)
    bcol = -np.ones(length,dtype=np.int64)

    bdat[:s] = loc_list[0]
    brow[:s] = loc_list[1]
    bcol[:s] = loc_list[2]

    # fdat, frow and fcol are variables that will store the full A matrix
    # a Gather command will send all local data (bdat, brow, bcol)
    # from each rank to the rank 0 process.

    fdat = None
    frow = None
    fcol = None

    # We need to initialize explicitely the variables in rank 0:
    if rank == 0:
        fdat = np.zeros(length*sizas,dtype=complex)
        frow = np.zeros(length*sizas,dtype=np.int64)
        fcol = np.zeros(length*sizas,dtype=np.int64)


    # and finally gather all local data to (fdat,frow,fcol)

    comm.Gather([bdat,MPI.DOUBLE_COMPLEX],[fdat,MPI.DOUBLE_COMPLEX],root=0)
    comm.Gather(brow,frow,root=0)
    comm.Gather(bcol,fcol,root=0)

    if rank == 0:

        ix = np.where(frow >= 0)
        A = ss.csr_matrix((fdat[ix], (frow[ix], fcol[ix])), shape=(ut.sizmat,ut.sizmat), dtype=complex)
        if par.forcing == 0:
            A = A/Bnorm

        toc = timer()
        print(' Matrix A assembled in', '{: 4.3f}'.format(toc-tic), 'seconds')
        tic = timer()

        np.savez('A.npz', data=A.data, indices=A.indices, indptr=A.indptr, shape=A.shape)
        toc = timer()
        print(' Matrix A written to disk in', '{: 4.3f}'.format(toc-tic), 'seconds')
        print('--------------------------------------------')

    comm.Barrier()


    # Free memory space
    #wig.wig_temp_free()
    #wig.wig_table_free()

    # ------------------------------------------------------------------------------------------------------------------ done!
    return 0



def bc_u_spherical(l,loc):
    '''
    Spherical boundary conditions for the velocity field,
    either no-penetration (for the inviscid case), stress-free or no-slip.
    '''
    inviscid = (par.Ek == 0) #boolean

    L = l*(l+1)

    if inviscid:
        num_rows_u = 1
        num_rows_v = 0
    else:
        num_rows_u = int(2 + 2*np.sign(par.ricb))  # 2 if no IC, 4 if present
        num_rows_v = int(1 + 1*np.sign(par.ricb))  # 1 if no IC, 2 if present

    ixu = ( par.m + 1 - ut.s )%2  #
    ixv = ( par.m + ut.s )%2
    if par.ricb > 0 :
        Tbu = bv.Tb
        Tbv = bv.Tb
    else:
        Tbu = bv.Tb[ixu::2,:]
        Tbv = bv.Tb[ixv::2,:]

    if loc == 'section_u':  # 2curl eqs

        out = ss.dok_matrix((num_rows_u, ut.N1),dtype=complex)

        if inviscid:

            out[ 0,:] = Tbu[:,0]  # u_r=0

        else:

            if par.bco == 0: # stress-free cmb

                if par.forcing == 9:  # m=2 radial forcing
                    out[ 0,:] = Tbu[:,0]  # P  = whatever we set on the B matrix
                    out[ 1,:] = Tbu[:,2] - (2-L)*Tbu[:,0]/ut.rcmb**2  # Nat Schaeffer's bc notes, eq. 49: P''=(2-L)*P/rcmb^2
                    #out[ 1,:] = Tbu[:,2]  # P''=0
                else:
                    out[ 0,:] = Tbu[:,0]  # P  =0
                    out[ 1,:] = Tbu[:,2]  # P''=0

            elif par.bco == 1: # no-slip cmb

                if par.forcing == 9:  # m=2 radial forcing
                    out[ 0,:] = Tbu[:,0]             # P  = whatever we set on the B matrix
                    out[ 1,:] = Tbu[:,1] + Tbu[:,0]  # P' + P/r = 0
                    #out[ 1,:] = Tbu[:,1]             # P' = 0
                else:
                    out[ 0,:] = Tbu[:,0]  # P  =0
                    out[ 1,:] = Tbu[:,1]  # P' =0

            if par.ricb > 0:

                if par.bci == 0: # stress-free icb
                    out[ 2,:] = bv.Ta[:,0]  # P  =0
                    out[ 3,:] = bv.Ta[:,2]  # P''=0

                elif par.bci == 1: # no-slip icb
                    out[ 2,:] = bv.Ta[:,0]  # P  =0
                    out[ 3,:] = bv.Ta[:,1]  # P' =0

        row0 = int(ut.N1*(l-ut.m_top)/2)
        col0 = int(ut.N1*(l-ut.m_top)/2)

    elif loc == 'section_v': # 1curl eqs

        if inviscid:

            return None

        else:

            out = ss.dok_matrix((num_rows_v, ut.N1),dtype=complex)

            if   par.bco == 0: # stress-free cmb
                out[ 0,:] = Tbv[:,1] - Tbv[:,0]/ut.rcmb  # T'-(T/r)=0

            elif par.bco == 1: # no-slip cmb
                out[ 0,:] = Tbv[:,0]  # T=0

            if par.ricb > 0 :

                if   par.bci == 0: # stress-free icb
                    out[ 1,:] = bv.Ta[:,1]-bv.Ta[:,0]/par.ricb  # T'-(T/r)=0

                elif par.bci == 1: # no-slip icb
                    out[ 1,:] = bv.Ta[:,0]  # T=0

            row0 = ut.n + int( ut.N1*(l-ut.m_bot)/2 )
            col0 = ut.n + int( ut.N1*(l-ut.m_bot)/2 )


    out = out.tocoo()
    out2 = [out.data, out.row + row0, out.col + col0]

    return out2



def bc_theta_spherical(l):
    '''
    Thermal boundary conditions for the temperature field,
    either isothermal or constant heat flux.
    '''
    num_rows_h = int(1 + 1*np.sign(par.ricb))  # 1 if no IC, 2 if present
    #num_rows_h = 2
    out = ss.dok_matrix((num_rows_h,ut.N1),dtype=complex)

    ixh = ( par.m + 1 - ut.s )%2
    if par.ricb > 0 :
        Tbh = bv.Tb
    else:
        Tbh = bv.Tb[ixh::2,:] # for cmb
        #Tch = bv.Tc[ixh::2,0] # for origin

    if par.bco_thermal == 0: # isothermal cmb
        out[ 0,:] = Tbh[:,0] # theta=0

    elif par.bco_thermal == 1: # constant heat flux at cmb
        out[ 0,:] = Tbh[:,1]   # theta'=0

    if par.ricb > 0 :
        if par.bci_thermal == 0:   # isothermal icb
            out[ 1,:] = bv.Ta[:,0] # theta=0
        elif par.bci_thermal == 1: # constant heat flux at icb
            out[ 1,:] = bv.Ta[:,1] # theta'=0

    row0 = 2*(par.hydro+par.magnetic)*ut.n + int(ut.N1*(l-ut.m_top)/2)
    col0 = row0

    out = out.tocoo()
    out2 = [out.data, out.row + row0, out.col + col0]

    return out2



def bc_xi_spherical(l):
    '''
    Boundary conditions for the composition field,
    either fixed composition or constant flux.
    '''
    num_rows_h = int(1 + 1*np.sign(par.ricb))  # 1 if no IC, 2 if present
    #num_rows_h = 2
    out = ss.dok_matrix((num_rows_h,ut.N1),dtype=complex)

    ixh = ( par.m + 1 - ut.s )%2
    if par.ricb > 0 :
        Tbh = bv.Tb
    else:
        Tbh = bv.Tb[ixh::2,:] # for cmb
        #Tch = bv.Tc[ixh::2,0] # for origin

    if par.bco_compositional == 0: # fixed composition cmb
        out[ 0,:] = Tbh[:,0] # xi=0

    elif par.bco_compositional == 1: # constant flux at cmb
        out[ 0,:] = Tbh[:,1]   # xi'=0

    if par.ricb > 0 :
        if par.bci_compositional == 0:   # fixed composition icb
            out[ 1,:] = bv.Ta[:,0] # xi=0
        elif par.bci_compositional == 1: # constant flux at icb
            out[ 1,:] = bv.Ta[:,1] # xi'=0

    row0 = ( (2*par.hydro+2*par.magnetic+par.thermal)*ut.n
               + int(ut.N1*(l-ut.m_top)/2) )
    col0 = row0

    out = out.tocoo()
    out2 = [out.data, out.row + row0, out.col + col0]

    return out2



def bc_b_thinlayer(l, loc, mu_vf, c, c1, boundary):
    '''
    Thin wall approximation boundary condition, following Roberts, Glatzmaier & Clune, GAFD 2010
    Assumes a thin electrically conducting layer at the top of the IC or at the bottom of the mantle.
    '''
    
    out = ss.dok_matrix((1, ut.N1),dtype=complex)
    
    if par.ricb == 0:
        if ut.symmB0 == -1:  # antisymmetric B0
            ixf = ( par.m + ut.s )%2
            ixg = ( par.m + 1 - ut.s )%2
        elif ut.symmB0 == 1:  # symmetric B0
            ixf = ( par.m + 1 - ut.s )%2
            ixg = ( par.m + ut.s )%2
        Tbf = bv.Tb[ixf::2,:]
        Tbg = bv.Tb[ixg::2,:]
    else:
        Tbf = bv.Tb
        Tbg = bv.Tb
    
    if boundary == 'cmb':
                
        epsj = 1
        rj   = ut.rcmb
        f    = Tbf[:,0]  #bv.P0_cmb
        f1   = Tbf[:,1]  #bv.P1_cmb
        f2   = Tbf[:,2]  #bv.P2_cmb
        g    = Tbg[:,0]  #bv.T0_cmb
        g1   = Tbg[:,1]  #bv.T1_cmb
        
        if par.ricb > 0:
            if 'perfect conductor' in par.innercore :
                delta_row = 2  # first two rows needed for the icb bc
            else :
                delta_row = 1  # first row for the icb bc
        else:
            delta_row = 0  # no ic, just cmb bc
        
    elif boundary == 'icb':
        
        epsj = -1
        rj   = par.ricb
        f    = bv.P0_icb
        f1   = bv.P1_icb
        f2   = bv.P2_icb
        g    = bv.T0_icb
        g1   = bv.T1_icb
        
        delta_row = 0
    
    F  = rj*f
    F1 = rj*f1 + f
    F2 = 2*f1 + rj*f2
    G  = rj*g
    G1 = rj*g1 + g    
    
    kj = (l+0.5)*epsj-0.5
    nabF = F2 - l*(l+1)*F/rj
    
    if loc == 'nocurl':  # section f
        
        out[0,:] = mu_vf*F1 + (kj/rj)*F + epsj*kj*c*F1 + epsj*c1*rj*(mu_vf+0.5*epsj*kj*c)*nabF
        
        if ut.symmB0 == -1:
            row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_bot)/2 )    # starting row
        elif ut.symmB0 == 1:
            row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_top)/2 )
        col0 = row0
    
    elif loc == '1curl':  # section g
        
        out[0,:] = G + epsj*rj*c1*G1
        
        if ut.symmB0 == -1:
            row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_top)/2 )   # starting row
        elif ut.symmB0 == 1:
            row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_bot)/2 )
        col0 = row0
    
    row1 = row0 + delta_row
    
    out = out.tocoo()
    out2 = [out.data, out.row + row1, out.col + col0]
    
    return out2



def bc_b_cmb(l,loc, innercore):
    '''
    Insulating boundary conditions for the magnetic field at the CMB
    '''

    # b must have the opposite symmetry as the flow u, if the background field is antisymmetric
    if par.ricb > 0 :
        Tbf = bv.Tb
        Tbg = bv.Tb
        delta_row = 1  # to make room for the icb bc
    else:
        if ut.symmB0 == -1:  # antisymmetric B0
            ixf = ( par.m + ut.s )%2
            ixg = ( par.m + 1 - ut.s )%2
        elif ut.symmB0 == 1:  # symmetric B0
            ixf = ( par.m + 1 - ut.s )%2
            ixg = ( par.m + ut.s )%2
        Tbf = bv.Tb[ixf::2,:]
        Tbg = bv.Tb[ixg::2,:]
        delta_row = 0


    if loc == 'section_f': # use loc_bot l's here (if external magnetic field is antisymm)

        out = ss.dok_matrix((1, ut.N1),dtype=complex)

        #out[0,:] = (l+1) * bv.P0_cmb + ut.rcmb * bv.P1_cmb   # cmb
        out[0,:] = (l+1) * Tbf[:,0] + ut.rcmb * Tbf[:,1]   # cmb

        if ut.symmB0 == -1:
            row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_bot)/2 )    # starting row
        elif ut.symmB0 == 1:
            row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_top)/2 )    # starting row
        col0 = row0

        if (par.ricb > 0) and ('perfect conductor' in innercore) :
            # one row extra to make room for the two rows of bc's needed for the icb if perfectly conducting
            delta_row += 1

    elif loc == 'section_g': # use loc_top l's here (if external magnetic field is antisymm)

        out = ss.dok_matrix((1, ut.N1),dtype=complex)

        #out[0,:] = bv.T0_cmb  # cmb
        out[0,:] = Tbg[:,0]

        if ut.symmB0 == -1:
            row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_top)/2 )   # starting row
        elif ut.symmB0 == 1:
            row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_bot)/2 )   # starting row
        col0 = row0

    # cmb bc goes on the first row if ricb = 0,
    # or on the second row if ricb>0,
    # or on the third row if the inner core is perfectly conducting (section_f only).
    row1 = row0 + delta_row

    out = out.tocoo()
    out2 = [out.data, out.row + row1, out.col + col0]

    return out2



def bc_b_icb(l,loc, innercore, rank, bpp, k):
    '''
    'material', uses "correct" b.c. in the electric field ( [nxE']=0, e.g. Satapathy 2013)
    'spatial', uses "incorrect" b.c. that everyone seems to use ( [nxE]=0 )
    '''
    nb = int((par.lmax-par.m+1)/2.)

    if innercore == 'insulator': #------------------------------------------------------------------------------- insulating inner core

        # only one row needed for the bc in the insulator case
        icb_diag = ss.dok_matrix((1, ut.N1),dtype=complex)

        if loc == 'nocurl': # use loc_bot l's here (if external magnetic field is antisymm) --------

            # Physics ------------------------------------------
            icb_diag[0,:] = l * bv.P0_icb - par.ricb * bv.P1_icb
            # --------------------------------------------------

            if ut.symmB0 == -1:
                row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_bot)/2 )  # starting row
            elif ut.symmB0 == 1:
                row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_top)/2 )  # starting row
            col0 = row0

        elif loc == '1curl': # use loc_top l's here (if external magnetic field is antisymm) -------

            # Physics ---------------
            icb_diag[0,:] = bv.T0_icb
            # -----------------------

            if ut.symmB0 == -1:
                row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_top)/2 )  # starting row
            elif ut.symmB0 == 1:
                row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_bot)/2 )  # starting row
            col0 = row0

        out = icb_diag.tocoo()
        out2 = [out.data, out.row + row0, out.col + col0]

    elif innercore == 'conducting': #------------------------------------------------------------------------------- inner core with conductivity equal to the outer core's
        # only one row needed for the bc in the conductor case
        icb_diag = ss.dok_matrix((1, ut.N1),dtype=complex)

        if loc == 'nocurl': # use loc_bot l's here (if external magnetic field is antisymm) --------

            # Physics ------------------------------------------
            bessel_wavenumber = (1-1j)*np.sqrt(par.forcing_frequency/2/par.Em)
            # the line just below works for lmax~150. 
            #icb_diag[0,:] = ut.jl(l,bessel_wavenumber*par.ricb,0) * bv.P0_icb - bessel_wavenumber * ut.jl(l,bessel_wavenumber*par.ricb,1) * bv.P1_icb
            # the line below should work for all lmax
            icb_diag[0,:] = bv.P0_icb - bessel_wavenumber * ut.dlogjl(l,bessel_wavenumber*par.ricb) * bv.P1_icb
            # --------------------------------------------------

            if ut.symmB0 == -1:
                row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_bot)/2 )  # starting row
            elif ut.symmB0 == 1:
                row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_top)/2 )  # starting row
            col0 = row0

        elif loc == '1curl': # use loc_top l's here (if external magnetic field is antisymm) -------

            # Physics ---------------
            bessel_wavenumber = (1-1j)*np.sqrt(par.forcing_frequency/2/par.Em)
            # the line just below works for lmax~150. 
            #icb_diag[0,:] = ut.jl(l,bessel_wavenumber*par.ricb,0) * bv.T0_icb - bessel_wavenumber * ut.jl(l,bessel_wavenumber*par.ricb,1) * bv.T1_icb
            # the line below should work for all lmax
            icb_diag[0,:] = bv.T0_icb - bessel_wavenumber * ut.dlogjl(l,bessel_wavenumber*par.ricb) * bv.T1_icb
            # -----------------------

            if ut.symmB0 == -1:
                row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_top)/2 )  # starting row
            elif ut.symmB0 == 1:
                row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_bot)/2 )  # starting row
            col0 = row0

        out = icb_diag.tocoo()
        out2 = [out.data, out.row + row0, out.col + col0]

    elif (innercore == 'perfect conductor, spatial') or (innercore == 'perfect conductor, material'):   #----- perfectly conducting inner core

        L = l*(l+1)

        if loc == 'nocurl': # use loc_bot l's here (if external magnetic field is antisymm) ------------ nocurl, b tor

            # two rows of bc's for the inner core
            icb_diag = ss.dok_matrix((2, ut.N1),dtype=complex)

            # Physics --------------------------------------------------------------------------------
            icb_diag[0,:] = bv.P0_icb  # first row, F = 0
            icb_diag[1,:] = par.Em*( -bv.P2_icb - (2/par.ricb)*bv.P1_icb + (L/(par.ricb**2))*bv.P0_icb )  # second row
            # ----------------------------------------------------------------------------------------

            row0 = 2*par.hydro*ut.n + int( ut.N1 * ( l - ut.m_bot)/2 )    # starting row
            col0 = row0

        elif loc == '1curl': # use loc_top l's here (if external magnetic field is antisymm) ----------- 1curl, b pol

            # only one row needed
            icb_diag = ss.dok_matrix((1, ut.N1),dtype=complex)

            # Physics ----------------------------------------------------
            icb_diag[0,:] = par.Em*( -bv.T1_icb - (1/par.ricb)*bv.T0_icb )
            # ------------------------------------------------------------

            row0 = (2*par.hydro+1)*ut.n + int( ut.N1*(l - ut.m_top)/2 )   # starting row
            col0 = row0

        if innercore == 'perfect conductor, material': # tangent *material* electric field is continuous across icb ------------------- material

            # no coupling with flow velocity so nothing else besides the on-diagonal terms computed above
            out = icb_diag.tocoo()
            out2 = [out.data, out.row + row0, out.col + col0]

        elif innercore == 'perfect conductor, spatial': # tangent *spatial* electric field continuous across icb ---------------------- spatial

            # include the on-diagonal terms as above
            out = icb_diag.tocoo()
            out2 = [out.data, out.row + row0, out.col + col0]


            # and now the velocity coupling terms
            if par.hydro == 1:

                if loc == 'nocurl': # ---------------------------------------------------------------------- nocurl

                    row00 = int( ut.N1 * ( l - ut.m_bot)/2 )
                    row0 = 2*ut.n + row00 + 1   # starting row (second row of bc's)
                    col0 = ut.n + row00

                    # l-1 terms ------------------------------------------------------------------------ l-1
                    if ((l-1 >= ut.m_bot) and (ut.symm1==-1)) or (ut.symm1==1) :

                        if ut.symm1 == -1 :
                            col0a = ( rank*bpp + k - 1 )* ut.N1 # left of diag if antisymm
                        elif ut.symm1 == 1 :
                            col0a = ( rank*bpp + k )* ut.N1     # on the diag if symm

                        icb_minus = ss.dok_matrix((1, ut.N1),dtype=complex)

                        C = np.sqrt(l**2-par.m**2)*(l-1)/(l*(2*l-1))

                        # Physics ----------------------------------------------------
                        icb_minus[0,:] = C*( -bv.P1_icb + (l-1)*bv.P0_icb/par.ricb  )
                        # ------------------------------------------------------------
                        out = icb_minus.tocoo()

                        out2[0] = np.concatenate([out2[0],out.data])
                        out2[1] = np.concatenate([out2[1],out.row+row0])  # second row
                        out2[2] = np.concatenate([out2[2],out.col+col0a])

                    # l terms -------------------------------------------------------------------------- l
                    icb_0 = ss.dok_matrix((1, ut.N1),dtype=complex)

                    C = -1j*par.m/L

                    # Physics ----------------
                    icb_0[0,:] =  C*bv.T0_icb
                    # ------------------------
                    out = icb_0.tocoo()

                    out2[0] = np.concatenate([out2[0],out.data])
                    out2[1] = np.concatenate([out2[1],out.row+row0])  # second row
                    out2[2] = np.concatenate([out2[2],out.col+col0])

                    # l+1 terms ------------------------------------------------------------------------ l+1
                    if ((l+1 <= ut.lmax_bot-1) and (ut.symm1==1)) or (ut.symm1==-1) :

                        if ut.symm1 == 1 :
                            col0b = ( rank*bpp + k + 1 )* ut.N1 # right of diag if symm
                        elif ut.symm1 == -1 :
                            col0b = ( rank*bpp + k )* ut.N1     # on diag if antisymm

                        icb_plus = ss.dok_matrix((1, ut.N1),dtype=complex)

                        C = -(l+2)*np.sqrt((l+par.m+1)*(l-par.m+1))/((2*l+3)*(l+1))

                        # Physics -------------------------------------------------
                        icb_plus[0,:] = C*( bv.P1_icb + (l+2)*bv.P0_icb/par.ricb )
                        # ---------------------------------------------------------
                        out = icb_plus.tocoo()

                        out2[0] = np.concatenate([out2[0],out.data])
                        out2[1] = np.concatenate([out2[1],out.row+row0])  # second row
                        out2[2] = np.concatenate([out2[2],out.col+col0b])


                if loc == '1curl': # ----------------------------------------------------------------------- 1curl

                    # first row (only one row needed here), goes with the -G'-(G/r) term

                    row11 = int( ut.N1*(l - ut.m_top)/2 )
                    row1 = 3*ut.n + row11   # starting row (first row of bc's)
                    col1 = row11

                    # l-1 terms ------------------------------------------------------------------------ l-1
                    if ((l-1 >= ut.m_top) and (ut.symm1==1)) or (ut.symm1==-1) :

                        if ut.symm1 == 1 :
                            col1a = nb*ut.N1 + ( rank*bpp + k - 1 )* ut.N1 # left of diag if symm
                        elif ut.symm1 == -1 :
                            col1a = nb*ut.N1 + ( rank*bpp + k )* ut.N1 # on the diag if antisymm

                        icb_minus = ss.dok_matrix((1, ut.N1),dtype=complex)

                        C = -(l-1)*np.sqrt(l**2-par.m**2)/(l*(2*l-1))

                        # Physics -------------------
                        icb_minus[0,:] = C*bv.T0_icb
                        # ---------------------------
                        out = icb_minus.tocoo()

                        out2[0] = np.concatenate([out2[0],out.data])
                        out2[1] = np.concatenate([out2[1],out.row+row1])
                        out2[2] = np.concatenate([out2[2],out.col+col1a])

                    # l terms -------------------------------------------------------------------------- l
                    icb_0 = ss.dok_matrix((1, ut.N1),dtype=complex)

                    C = 1j*par.m/L

                    # Physics ---------------------------------------------------
                    icb_0[0,:] = C*( bv.P1_icb + (l**2+l+1)*bv.P0_icb/par.ricb )
                    # -----------------------------------------------------------
                    out = icb_0.tocoo()

                    out2[0] = np.concatenate([out2[0],out.data])
                    out2[1] = np.concatenate([out2[1],out.row+row1])
                    out2[2] = np.concatenate([out2[2],out.col+col1])

                    # l+1 terms ------------------------------------------------------------------------ l+1
                    if ((l+1 <= ut.lmax_top-1) and (ut.symm1==-1)) or (ut.symm1==1) :

                        if ut.symm1 == -1 :
                            col1b = nb*ut.N1 + ( rank*bpp + k + 1 )* ut.N1 # right of diag if antisymm
                        elif ut.symm1 == 1 :
                            col1b = nb*ut.N1 + ( rank*bpp + k )* ut.N1 # on diag if symm

                        icb_plus = ss.dok_matrix((1, ut.N1),dtype=complex)

                        C = -(l+2)*np.sqrt((l+par.m+1)*(l-par.m+1))/((2*l+3)*(l+1))

                        # Physics ------------------
                        icb_plus[0,:] = C*bv.T0_icb
                        # --------------------------
                        out = icb_plus.tocoo()

                        out2[0] = np.concatenate([out2[0],out.data])
                        out2[1] = np.concatenate([out2[1],out.row+row1])
                        out2[2] = np.concatenate([out2[2],out.col+col1b])

    return out2



'''
def Clam(L,l,m,n, lamb0):
    #
    tmp1 = wig.wig3jj( 2* l , 2* lamb0 , 2* L , 2* m, 0 , 2*(-m) )
    tmp2 = wig.wig3jj( 2* l , 2* lamb0 , 2* L , 2* n, 0 , 2*(-n) )
    out = (-1)**(m+n)*(2*L+1.)*tmp1*tmp2

    return out
'''



if __name__ == "__main__":
    sys.exit(main())
