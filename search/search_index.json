{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>KOR-ee, from the greek \u039a\u03cc\u03c1\u03b7, the queen of the underworld, daughter of Zeus and Demeter. Kore is a numerical tool to study the core flow within rapidly rotating planets or other rotating fluids contained within near-spherical boundaries. The current version solves the linear Navier-Stokes and induction equations for a viscous, incompressible and conductive fluid with an externally imposed magnetic field, and enclosed within a rotating spherical shell.</p> <p>Kore assumes all dynamical variables to oscillate in a harmonic fashion. The oscillation frequency can be imposed externally, as is the case when doing forced motion studies (e.g. tidal forcing), or it can be obtained as part of the solution to an eigenvalue problem. In Kore's current implementation, the eigenmodes are the inertial modes of the rotating fluid. Inertial modes are the global modes of a rotating flow in which the Coriolis force participates prominently in the restoring force balance.</p> <p>Kore's distinctive feature is the use of a very efficient spectral method employing Gegenbauer (also known as ultraspherical) polynomials as a basis in the radial direction. This approach leads to sparse matrices representing the differential equations, as opposed to dense matrices, as in traditional Chebyshev colocation methods. Sparse matrices have smaller memory-footprint and are more suitable for systematic core flow studies at extremely low viscosities (or small Ekman numbers).</p> <p>Kore is free for everyone to use, with no restrictions. Too often in the scientific literature the numerical methods used are presented with enough detail to guarantee reproducibility, but only in principle. Without access to the actual implementation of those methods, which would require a significant amount of work and time to develop, readers are left effectively without the possibility to reproduce or verify the results presented. This leads to very slow scientific progress. We share our code to avoid this.</p> <p>If this code is useful for your research, we invite you to cite the relevant papers (coming soon) and hope that you can also contribute to the project.</p>"},{"location":"page2/","title":"Installation Notes","text":"<p>To run <code>kore</code> we need the PETSc/SLEPc packages and their python bindings petsc4py/slepc4py. PETSc needs to be compiled with support for complex scalars. MUMPS and SuperLU_dist are external packages that need to be installed together with PETSc.</p> <p>If you are interested in problems that involve very large matrices, for instance when considering extremely small viscosities, we recommend doing so with a machine with at least 128 GB of memory. The number of processing cores is not critical, eight are fine, 24 are plenty. Small to moderate size matrices can be solved using a laptop, depending on available memory. </p> <p>From our experience the PETSc version that has allowed us to solve the largest problems is version 3.9.4. That version requires python 3.7, however. Newer PETSc versions seem to have much larger memory footprint, although they can still handle medium size problems without issues. So, our advice is to install PETSc version 3.9.3 if the problem involves very large matrices, otherwise it is better to stick to the most recent PETSc release.</p>"},{"location":"page2/#installing-petscslepc-on-macos","title":"Installing PETSc/SLEPc on MacOS","text":"<p>It is convenient to have a dedicated python environment to use with <code>kore</code>. It is quite simple to create and activate it:</p> <pre><code>python3 -m venv kore_env\nsource kore_env/bin/activate\n</code></pre> <p>Then we need to install scipy and cython in that environment: <pre><code>pip3 install scipy cython\n</code></pre></p> <p>Now we download the latest PETSc/SLEPc releases using <code>git</code> <pre><code>git clone -b release https://gitlab.com/petsc/petsc.git petsc\ngit clone -b release https://gitlab.com/slepc/slepc slepc\n</code></pre></p> <p>We go now into the newly created <code>petsc</code> folder and configure PETSc: <pre><code>cd petsc\n./configure --with-petsc4py --download-mpi4py --download-mpich --with-scalar-type=complex --download-mumps --download-parmetis --download-metis --download-scalapack --download-fblaslapack --with-debugging=0 --download-superlu_dist --download-ptscotch CXXOPTFLAGS='-O3 -march=native' FOPTFLAGS='-O3 -march=native' COPTFLAGS='-O3 -march=native' --download-bison\n</code></pre> Then we build PETSc: <pre><code>make PETSC_DIR=/path/to/petsc PETSC_ARCH=arch-darwin-c-opt all\n</code></pre> where you must replace <code>/path/to/petsc</code> with the actual path for your case. Before checking that everything works we must tell python where to find <code>petsc4py</code> and <code>mpi4py</code>, which were compiled along in the step above: <pre><code>export PYTHONPATH=/path/to/petsc/arch-darwin-c-opt/lib\n</code></pre> where again we must replace <code>/path/to/petsc</code> with the actual path. Now we test the installation: <pre><code>make PETSC_DIR=/path/to/petsc PETSC_ARCH=arch-darwin-c-opt check\n</code></pre> If no errors appear then you can proceed to install SLEPc. If an error is reported due to python not being able to find PETSc (even though we just updated the <code>PYTHONPATH</code>), but the other MPI tests were successful, then don't worry, it is safe to ignore the error.</p> <p>We need to setup some environment variables before installing SLEPc: <pre><code>export PETSC_DIR=/path/to/petsc\nexport PETSC_ARCH=arch-darwin-c-opt\nexport SLEPC_DIR=/path/to/slepc\n</code></pre></p> <p>Now go to the slepc folder, configure and build SLEPc: <pre><code>cd $SLEPC_DIR\n./configure\nmake\nmake check\n</code></pre> The last step is to install slepc4py, which is distributed along with SLEPc: <pre><code>cd $SLEPC_DIR/src/binding/slepc4py\npython3 setup.py build\npython3 setup.py install\n</code></pre> Almost there now. We need to update the <code>PATH</code> environment variable so that we can use the MPI library provided by PETSc instead of the one provided by your system, if any: <pre><code>export PATH=$PETSC_DIR/$PETSC_ARCH/bin:$PATH\n</code></pre></p> <p>It is a good idea to keep the necessary commands for initialization in a separate file. It should contain the following lines: <pre><code>source /path/to/kore_env/bin/activate\nexport PETSC_DIR=/path/to/petsc\nexport PETSC_ARCH=arch-darwin-c-opt\nexport SLEPC_DIR=/path/to/slepc\nexport PYTHONPATH=$PETSC_DIR/$PETSC_ARCH/lib\nexport PATH=$PETSC_DIR/$PETSC_ARCH/bin:$PATH\n</code></pre> We can write that to a file named e.g. <code>kore_env.sh</code> in your home directory, so every time you need to prepare to run <code>kore</code> we do first: <pre><code>source $HOME/kore_env.sh\n</code></pre></p>"},{"location":"page2/#installing-on-linux","title":"Installing on Linux","text":"<p>Coming soon</p>"},{"location":"page2/#shtns","title":"SHTns","text":"<p>Coming soon</p>"},{"location":"page3/","title":"Non-dimensionalization","text":"<p>For numerical convenience we use dimensionless variables when solving the Navier Stokes equation, the induction equation, and the heat equation. A non-dimensionalization procedure is always possible thanks to the Buckingham-\\(\\pi\\) theorem.</p>"},{"location":"page3/#the-momentum-equation","title":"The momentum equation","text":"<p>In a reference frame rotating with angular speed \\(\\Omega\\), the dimensional form of the linear momentum equation (i.e. the Navier-Stokes equation) describing the acceleration \\(\\partial_t \\mathbf{u}\\) of a small fluid parcel with density \\(\\rho\\), including buoyancy and the Lorentz force, is:  </p> \\[ \\rho\\partial_t \\mathbf{u} +2\\rho\\,\\mathbf{\\Omega}\\times\\mathbf{u}=-\\nabla p +\\frac{1}{\\mu_0}(\\nabla \\times \\mathbf{B})\\times \\mathbf{B} + \\rho\\mathbf{g}+\\rho\\nu\\nabla^2{\\mathbf{u}}, \\] <p>where \\(p\\) is the reduced pressure, \\(\\mathbf{B}\\) the magnetic field, and \\(\\nu\\) is the kinematic viscosity of the fluid. Assume small density perturbations \\(\\rho'\\) following</p> \\[ \\rho=\\rho_0+\\rho'=\\rho_0-\\rho_0\\alpha\\theta, \\] <p>where \\(\\alpha\\) is the fluid's thermal expansion coefficient and \\(\\theta\\) is the temperature variation from the isentropic temperature profile \\(T(r)\\). Assume also a gravitational acceleration following</p> \\[ \\mathbf{g}=-g_0\\frac{r}{R}\\mathbf{\\hat r}. \\] <p>Within the Boussinesq approximation the density variations enter only through the buoyancy force, so</p> \\[ \\rho\\mathbf{g} \\longrightarrow \\rho' \\mathbf{g} = \\rho_0 \\alpha g_0 \\frac{r}{R} \\theta \\mathbf{\\hat r}. \\] <p>Now we make the dimensional units explicit. With \\(L\\) being the unit of length, \\(\\tau\\) the unit of time,  \\(\\theta^*\\) the unit of temperature, \\(P^*\\) the unit of pressure, and \\(\\mathbf{\\hat z}\\) the unit vector along \\(\\mathbf{\\Omega}\\), then the momentum equation, after dividing by \\(\\rho_0\\), is</p> \\[ \\frac{L}{\\tau^2}\\,\\partial_t \\mathbf{u} +L\\frac{\\Omega}{\\tau}\\, 2\\mathbf{\\hat z}\\times\\mathbf{u}=-\\frac{P^*}{\\rho_0 L} \\nabla p +  \\frac{B_0^2}{L\\rho_0 \\mu_0}(\\nabla \\times \\mathbf{B})\\times \\mathbf{B}          +  \\frac{\\alpha g_0 \\theta^*}{R} L r \\theta\\mathbf{\\hat r}+\\frac{\\nu }{\\tau L}\\nabla^2 \\mathbf{u}, \\] <p>where it is understood that the variables \\(r, t, \\mathbf{u}, p, \\theta, \\mathbf{B}\\) are now dimensionless. Multiply the equation by \\(\\tau^2/L\\) and get</p> \\[ \\partial_t \\mathbf{u} + 2\\,\\Omega\\tau\\,\\mathbf{\\hat z}\\times\\mathbf{u}=- \\nabla p + \\frac{\\tau^2 B_0^2}{L^2\\rho_0 \\mu_0}(\\nabla \\times \\mathbf{B})\\times \\mathbf{B} + \\tau^2 \\frac{\\alpha g_0 \\theta^*}{R} r \\theta \\mathbf{\\hat r}+\\tau\\frac{\\nu}{L^2}\\nabla^2 \\mathbf{u}. \\] <p>Above we have chosen the pressure scale as \\(P^*=\\rho_0 L^2/\\tau^2\\). For the time being we leave the temperature scale \\(\\theta^*\\) unspecified, and define the Ekman number \\(E\\) as</p> \\[ E \\equiv \\frac{\\nu}{\\Omega L^2}, \\] <p>The Lehnert number \\(Le\\) as</p> \\[ Le \\equiv \\frac{B_0}{\\Omega L \\sqrt{\\rho_0\\mu_0}}, \\] <p>the Rayleigh number \\(Ra\\) as</p> \\[ Ra \\equiv \\frac{\\alpha g_0 \\theta^* L^4}{\\nu\\kappa R}, \\] <p>and the Prandtl number \\(Pr\\) as</p> \\[ Pr \\equiv \\frac{\\nu}{\\kappa}, \\] <p>where \\(\\kappa\\) is the thermal diffusivity of the fluid So, the momentum equation becomes</p> \\[ \\partial_t \\mathbf{u} + 2\\,(\\Omega\\tau)\\,\\mathbf{\\hat z}\\times\\mathbf{u}=-\\nabla p + (\\Omega\\tau)^2 Le^2(\\nabla \\times \\mathbf{B})\\times \\mathbf{B}  + (\\Omega\\tau)^2 E^2\\frac{Ra}{Pr}\\,\\theta\\, r\\, \\mathbf{\\hat r}+(\\Omega\\tau)\\,E\\,\\nabla^2 \\mathbf{u}. \\] <p>Alternatively, if we deal with problems without viscosity or thermal diffusion where the Rayleigh number diverges, it is better to define a reference Brunt-V\u00e4is\u00e4l\u00e4 frequency \\(N_0\\) such that</p> \\[ N_0^2 \\equiv -\\frac{\\alpha g_0 \\theta^*}{R}. \\] <p>If the Rayleigh number is finite then we can write</p> \\[ E^2\\frac{Ra}{Pr} = -\\frac{N_0^2}{\\Omega^2}. \\] <p>The momentum equation, using the reference Brunt-V\u00e4is\u00e4l\u00e4 frequency reads</p> \\[ \\partial_t \\mathbf{u} + 2\\,(\\Omega\\tau)\\,\\mathbf{\\hat z}\\times\\mathbf{u}=-\\nabla p + (\\Omega\\tau)^2 Le^2(\\nabla \\times \\mathbf{B})\\times \\mathbf{B}  - (\\Omega\\tau)^2 \\frac{N_0^2}{\\Omega^2}\\,\\theta\\, r\\, \\mathbf{\\hat r}+(\\Omega\\tau)\\,E\\,\\nabla^2 \\mathbf{u}. \\] <p>A common choice for the time scale is the rotation time scale, so \\(\\tau=1/\\Omega\\) and the \\((\\Omega\\tau)\\) factors go away. Another choice is the viscous diffusion time scale, with \\(\\tau=L^2/\\nu\\), in which case \\(\\Omega\\tau=1/E\\). Yet another choice is the Alfv\u00e9n wave time scale, with \\(\\tau=L \\sqrt{\\mu_0\\rho_0}/B_0\\) so that \\(\\Omega\\tau=1/Le\\).</p>"},{"location":"page3/#the-induction-equation","title":"The induction equation","text":"<p>The induction equation in dimensional form is</p> \\[ \\partial_t \\mathbf{B} = \\nabla \\times (\\mathbf{u} \\times \\mathbf{B}) + \\eta \\nabla^2 \\mathbf{B}, \\] <p>where \\(\\eta\\) is the magnetic diffusivity. Making the dimensional scale factors explicit we get</p> \\[ \\frac{B_0}{\\tau} \\partial_t \\mathbf{B} = \\frac{B_0}{\\tau} \\nabla \\times (\\mathbf{u} \\times \\mathbf{B}) + \\eta \\frac{B_0}{L^2}  \\nabla^2\\mathbf{B}, \\] <p>where \\(\\mathbf{u}, \\mathbf{B}, t\\) are now dimensionless. Multiply now by \\(\\tau/B_0\\) and obtain</p> \\[ \\partial_t \\mathbf{B} = \\nabla \\times (\\mathbf{u} \\times \\mathbf{B}) + (\\Omega\\tau)E_\\eta \\nabla^2 \\mathbf{B}, \\] <p>where \\(E_\\eta\\) is the magnetic Ekman number defined as</p> \\[ E_\\eta \\equiv \\frac{\\eta}{\\Omega L^2}. \\]"},{"location":"page3/#the-heat-equation","title":"The heat equation","text":"<p>The heat equation in its dimensional form is</p> \\[ \\partial_t \\theta=-\\mathbf{u}\\cdot\\nabla T+\\kappa \\nabla^2 \\theta. \\] <p>We assume that an isentropic temperature background \\(T(r)\\) exists, which is only a function of radius. Its gradient is then \\(\\nabla T=\\mathbf{\\hat r}\\,\\mathrm{d}T/\\mathrm{d}r\\). Now we write \\(\\mathrm{d}T/\\mathrm{d}r=C\\,f(r)\\), where \\(C\\) is a scale factor for the gradient (can be negative) and \\(f(r)\\) is a dimensionless function of \\(r\\) (with \\(r\\) also dimensionless). Then we can write the heat equation, using this time dimensionless variables exclusively as</p> \\[ \\partial_t \\theta=-\\frac{LC}{\\theta^*}\\,u_r\\,f(r)+(\\Omega\\tau)\\frac{E}{Pr} \\nabla^2 \\theta. \\] <p>In <code>kore</code> we choose always the temperature scale as \\(\\theta^*=-LC\\) so that the heat equation reads simply</p> \\[ \\partial_t \\theta=u_r\\,f(r)+(\\Omega\\tau)\\frac{E}{Pr} \\nabla^2 \\theta. \\] <p>A temperature profile with a linear gradient is common in the literature. In that case \\(\\partial_r T=-\\beta r\\) (dimensional). In dimensionless variables this is \\(-\\beta L r\\) (\\(r\\) now dimensionless), so that the temperature scale is \\(\\theta^*=\\beta L^2\\). And if the length scale is the CMB radius, i.e. \\(L=R\\), then the Rayleigh number becomes</p> \\[ Ra = \\frac{\\alpha g_0 \\beta R^5}{\\nu\\kappa}. \\]"}]}